#pragma once
#ifndef GEAR_GRAMMAR
#define GEAR_GRAMMAR

#include "Gear-Lexer.hxx"

namespace Gear {
	enum GrammarType {
		GRAMMAR_TYPE_COMMENT = 4,
		GRAMMAR_TYPE_STRING_LITERAL,
		GRAMMAR_TYPE_HEX_LITERAL,
		GRAMMAR_TYPE_OCT_LITERAL,
		GRAMMAR_TYPE_BIN_LITERAL,
		GRAMMAR_TYPE_DEC_LITERAL,
		GRAMMAR_TYPE_SHR_ASSIGN,
		GRAMMAR_TYPE_SHL_ASSIGN,
		GRAMMAR_TYPE_ADD_ASSIGN,
		GRAMMAR_TYPE_SUB_ASSIGN,
		GRAMMAR_TYPE_MUL_ASSIGN,
		GRAMMAR_TYPE_DIV_ASSIGN,
		GRAMMAR_TYPE_MOD_ASSIGN,
		GRAMMAR_TYPE_AND_ASSIGN,
		GRAMMAR_TYPE_OR_ASSIGN,
		GRAMMAR_TYPE_XOR_ASSIGN,
		GRAMMAR_TYPE_EQUAL_TO,
		GRAMMAR_TYPE_NOT_EQUAL,
		GRAMMAR_TYPE_GREATER_EQUAL,
		GRAMMAR_TYPE_LESS_EQUAL,
		GRAMMAR_TYPE_SHR,
		GRAMMAR_TYPE_SHL,
		GRAMMAR_TYPE_INC,
		GRAMMAR_TYPE_DEC,
		GRAMMAR_TYPE_ADD,
		GRAMMAR_TYPE_SUB,
		GRAMMAR_TYPE_MUL,
		GRAMMAR_TYPE_DIV,
		GRAMMAR_TYPE_MOD,
		GRAMMAR_TYPE_AND,
		GRAMMAR_TYPE_OR,
		GRAMMAR_TYPE_XOR,
		GRAMMAR_TYPE_NOT,
		GRAMMAR_TYPE_COMPLEMENT,
		GRAMMAR_TYPE_PREPROCESSOR_DIRECTIVE,
		GRAMMAR_TYPE_ASSIGN,
		GRAMMAR_TYPE_GREATER_THAN,
		GRAMMAR_TYPE_LESS_THAN,
		GRAMMAR_TYPE_OPENING_PARENTHESIS,
		GRAMMAR_TYPE_CLOSING_PARENTHESIS,
		GRAMMAR_TYPE_OPENING_BRACKET,
		GRAMMAR_TYPE_CLOSING_BRACKET,
		GRAMMAR_TYPE_OPENING_BRACE,
		GRAMMAR_TYPE_CLOSING_BRACE,
		GRAMMAR_TYPE_DOT,
		GRAMMAR_TYPE_COMMA,
		GRAMMAR_TYPE_COLON,
		GRAMMAR_TYPE_SEMICOLON,
		GRAMMAR_TYPE_IDENTIFIER,
		GRAMMAR_TYPE_RAW_DATA,
	};

	const std::vector<Token> Tokens = {
		{ GRAMMAR_TYPE_SPACE, R"([\t\f\v ])" },
		{ GRAMMAR_TYPE_LINE_BREAK, R"((\r\n|\n|\r))" },
		{ GRAMMAR_TYPE_COMMENT, R"(<!([\s\S]*?)!>)" },
		{ GRAMMAR_TYPE_STRING_LITERAL, R"("(\\[\s\S]|[^\"])*")" },
		{ GRAMMAR_TYPE_HEX_LITERAL, R"([\+\-]?0[xX][0-9a-fA-F]+\b)" },
		{ GRAMMAR_TYPE_OCT_LITERAL, R"([\+\-]?0[oO]?[0-7]+\b)" },
		{ GRAMMAR_TYPE_BIN_LITERAL, R"([\+\-]?0[bB][01]+\b)" },
		{ GRAMMAR_TYPE_DEC_LITERAL, R"([\+\-]?[0-9]+\b)" },
		{ GRAMMAR_TYPE_SHR_ASSIGN, R"(>>=)" },
		{ GRAMMAR_TYPE_SHL_ASSIGN, R"(<<=)" },
		{ GRAMMAR_TYPE_ADD_ASSIGN, R"(\+=)" },
		{ GRAMMAR_TYPE_SUB_ASSIGN, R"(\-=)" },
		{ GRAMMAR_TYPE_MUL_ASSIGN, R"(\*=)" },
		{ GRAMMAR_TYPE_DIV_ASSIGN, R"(/=)" },
		{ GRAMMAR_TYPE_MOD_ASSIGN, R"(%=)" },
		{ GRAMMAR_TYPE_AND_ASSIGN, R"(&=)" },
		{ GRAMMAR_TYPE_OR_ASSIGN, R"(\|=)" },
		{ GRAMMAR_TYPE_XOR_ASSIGN, R"(\^=)" },
		{ GRAMMAR_TYPE_EQUAL_TO, R"(==)" },
		{ GRAMMAR_TYPE_NOT_EQUAL, R"(!=)" },
		{ GRAMMAR_TYPE_GREATER_EQUAL, R"(>=)" },
		{ GRAMMAR_TYPE_LESS_EQUAL, R"(<=)" },
		{ GRAMMAR_TYPE_SHR, R"(>>)" },
		{ GRAMMAR_TYPE_SHL, R"(<<)" },
		{ GRAMMAR_TYPE_INC, R"(\+\+)" },
		{ GRAMMAR_TYPE_DEC, R"(\-\-)" },
		{ GRAMMAR_TYPE_ADD, R"(\+)" },
		{ GRAMMAR_TYPE_SUB, R"(\-)" },
		{ GRAMMAR_TYPE_MUL, R"(\*)" },
		{ GRAMMAR_TYPE_DIV, R"(/)" },
		{ GRAMMAR_TYPE_MOD, R"(%)" },
		{ GRAMMAR_TYPE_AND, R"(&)" },
		{ GRAMMAR_TYPE_OR, R"(\|)" },
		{ GRAMMAR_TYPE_XOR, R"(\^)" },
		{ GRAMMAR_TYPE_NOT, R"(!)" },
		{ GRAMMAR_TYPE_COMPLEMENT, R"(~)" },
		{ GRAMMAR_TYPE_PREPROCESSOR_DIRECTIVE, R"(@)" },
		{ GRAMMAR_TYPE_ASSIGN, R"(=)" },
		{ GRAMMAR_TYPE_GREATER_THAN, R"(>)" },
		{ GRAMMAR_TYPE_LESS_THAN, R"(<)" },
		{ GRAMMAR_TYPE_OPENING_PARENTHESIS, R"(\()" },
		{ GRAMMAR_TYPE_CLOSING_PARENTHESIS, R"(\))" },
		{ GRAMMAR_TYPE_OPENING_BRACKET, R"(\[)" },
		{ GRAMMAR_TYPE_CLOSING_BRACKET, R"(\])" },
		{ GRAMMAR_TYPE_OPENING_BRACE, R"(\{)" },
		{ GRAMMAR_TYPE_CLOSING_BRACE, R"(\})" },
		{ GRAMMAR_TYPE_DOT, R"(\.)" },
		{ GRAMMAR_TYPE_COMMA, R"(,)" },
		{ GRAMMAR_TYPE_COLON, R"(\:)" },
		{ GRAMMAR_TYPE_SEMICOLON, R"(\;)" },
		{ GRAMMAR_TYPE_IDENTIFIER, R"(\b[_a-zA-Z]\w*\b)" },
		{ GRAMMAR_TYPE_RAW_DATA, "" },
	};
}

#endif